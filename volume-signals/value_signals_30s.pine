//@version=6
indicator("Volume Value", "value", format = format.volume, overlay = false, max_labels_count = 500)  // timeframe="30S"

debugLabelUp(txt,offset=0,overlay=true) =>
    label.new(bar_index+offset, high, txt, yloc = yloc.abovebar, style = label.style_arrowdown, force_overlay = overlay, textcolor = color.black)
debugLabelDn(txt,offset=0,overlay=true) =>
    label.new(bar_index+offset, low, txt, yloc = yloc.belowbar, style = label.style_arrowup, force_overlay = overlay, textcolor = color.black)


p99bars = input.int(5000, "30S P99 Bars", inline = "000")
p99 = input.float(99.5, "%", inline = "000")

p99m1bars = input.int(2000, "1m P99 Bars", inline = "001")
p99m1 = input.float(99.5, "%", inline = "001")

p99m3bars = input.int(1000, "3m P99 Bars", inline = "003")
p99m3 = input.float(99.5, "%", inline = "003")

p99m5bars = input.int(1000, "5m P99 Bars", inline = "005")
p99m5 = input.float(99.5, "%", inline = "005")

p99m10bars = input.int(1000, "10m P99 Bars", inline = "010")
p99m10 = input.float(99.5, "%", inline = "010")

var float step1p = input.float(0.5, "step x1 %", inline = "1") / 100  // 0.5 %
var float step10p = input.float(5, "step x10 %", inline = "1") / 100  // 5 %

var float zonediv = input.float(8, "Level zone (1/x)", inline = "2")

dispBg = input.bool(true, "Background Highlights", group = "Show/Hide")


var divisor = array.from(
     0.0001, 0.0002, 0.0005,
     0.001, 0.002, 0.005,
     0.01, 0.02, 0.05,
     0.1, 0.2, 0.5,
     1, 2, 5,
     10, 20, 50,
     100, 200, 500,
     1000, 2000, 5000,
     10000, 20000, 50000)

dividx1 = divisor.binary_search_rightmost(close * step1p)
step1 = divisor.get(dividx1)
roundzone1 = step1 / zonediv

openint_ceil = step1 * math.ceil(open / step1)
openint_floor = step1 * math.floor(open / step1)
closeint_ceil = step1 * math.ceil(close / step1)
closeint_floor = step1 * math.floor(close / step1)

highint_floor = step1 * math.floor(high / step1)
lowint_ceil = step1 * math.ceil(low / step1)

highint_ceil = step1 * math.ceil(high / step1)
lowint_floor = step1 * math.floor(low / step1)


value = volume == 0.0 ? na : volume * hl2


vcum1m = math.sum(value, 2)     //  1 min
vcum3m = math.sum(value, 6)     //  3 min
vcum5m = math.sum(value, 10)    //  5 min
vcum10m = math.sum(value, 20)   // 10 min

[vp99m1,vp100m1] = request.security(syminfo.tickerid, "1", [
     ta.percentile_nearest_rank(value, p99m1bars, p99m1),
     ta.percentile_nearest_rank(value, p99m1bars, 100)
     ], lookahead = barmerge.lookahead_on)

[vp99m3,vp100m3] = request.security(syminfo.tickerid, "3", [
     ta.percentile_nearest_rank(value, p99m3bars, p99m3),
     ta.percentile_nearest_rank(value, p99m3bars, 100)
     ], lookahead = barmerge.lookahead_on)

[vp99m5,vp100m5] = request.security(syminfo.tickerid, "5", [
     ta.percentile_nearest_rank(value, p99m5bars, p99m5),
     ta.percentile_nearest_rank(value, p99m5bars, 100)
     ], lookahead = barmerge.lookahead_on)

[vp99m10,vp100m10] = request.security(syminfo.tickerid, "10", [
     ta.percentile_nearest_rank(value, p99m10bars, p99m10),
     ta.percentile_nearest_rank(value, p99m10bars, 100)
     ], lookahead = barmerge.lookahead_on)

vp99 = ta.percentile_nearest_rank(value, p99bars, p99)
vp100 = ta.percentile_nearest_rank(value, p99bars, 100)


isvalueP100 = value >= vp100
isvalueP99 = value >= vp99

isvcum1m = vcum1m >= vp99m1
isvcum3m = vcum3m >= vp99m3
isvcum5m = vcum5m >= vp99m5
isvcum10m = vcum10m >= vp99m10

isanyval = isvalueP100 or isvalueP99
isanycum = isvcum1m or isvcum3m or isvcum5m or isvcum10m
isany = isanyval or isanycum


enum StateLevel
    near
    reached
    touched
    crossed
    crossed_multiple

StateLevel state_up = na
StateLevel state_dn = na
txt = array.new<string>()
level_crossed_arr = array.new<float>()
level_touched = float(na)
level_near = float(na)
var last_level_crossed = float(na)
var last_level_touched = float(na)
var last_level_near = float(na)
var level_crossed_count = 0
var level_touched_count = 0
var level_near_count = 0
barsanyval = ta.barssince(isanyval)
barsanycum = ta.barssince(isanyval)
barsany = ta.barssince(isanyval)


lastdirection(baseprice,lookback=14) =>
    result = 0
    for i = 1 to lookback
        if close[i] > baseprice
            result := 1
            break
        else if close[i] < baseprice
            result := -1
            break
    result
lvl(l) =>
    switch lastdirection(l)
        1 => "%"
        -1 => "#"
        0 => "0"


if barstate.isconfirmed

    if closeint_ceil[1] < closeint_floor  // CROSSED UP
        from_num = close[1] == closeint_ceil[1] ? closeint_ceil[1] + step1 : closeint_ceil[1]
        to_num = closeint_floor
        for level = from_num to to_num by step1
            level_crossed_arr.push(level)
            level_crossed_count := level_crossed_count + 1
            txt.push(str.format("{0}@",level))
        state_up := txt.size() > 1 ? StateLevel.crossed_multiple : StateLevel.crossed
    else if closeint_ceil[1] < openint_floor
        from_num = close[1] == closeint_ceil[1] ? closeint_ceil[1] + step1 : closeint_ceil[1]
        to_num = openint_floor
        for level = from_num to to_num by step1
            level_crossed_arr.push(level)
            level_crossed_count := level_crossed_count + 1
            txt.push(str.format("{0}@",level))
        state_up := txt.size() > 1 ? StateLevel.crossed_multiple : StateLevel.crossed
    else if closeint_ceil[1] == closeint_floor and lastdirection(closeint_floor) < 0 and
         (close[1] < close) and
         (close[1] <= closeint_ceil[1] and closeint_ceil[1] < close)
        level_crossed_arr.push(closeint_floor)
        level_crossed_count := level_crossed_count + 1
        txt.push(str.format("{0}^{1}",closeint_floor,lvl(closeint_floor)))
        state_up := StateLevel.crossed
    else if closeint_ceil[1] == openint_floor and lastdirection(openint_floor) < 0 and
         (close[1] < open) and
         (close[1] <= closeint_ceil[1] and closeint_ceil[1] < open)
        level_crossed_arr.push(openint_floor)
        level_crossed_count := level_crossed_count + 1
        txt.push(str.format("{0}*{1}",openint_floor,lvl(openint_floor)))
        state_up := StateLevel.crossed

    if closeint_floor[1] > closeint_ceil  // CROSSED DN
        from_num = close[1] == closeint_floor[1] ? closeint_floor[1] - step1 : closeint_floor[1]
        to_num = closeint_ceil
        for level = from_num to to_num by step1
            level_crossed_arr.push(level)
            level_crossed_count := level_crossed_count + 1
            txt.push(str.format("{0}@",level))
        state_dn := txt.size() > 1 ? StateLevel.crossed_multiple : StateLevel.crossed
    else if closeint_floor[1] > openint_ceil
        from_num = close[1] == closeint_floor[1] ? closeint_floor[1] - step1 : closeint_floor[1]
        to_num = openint_ceil
        for level = from_num to to_num by step1
            level_crossed_arr.push(level)
            level_crossed_count := level_crossed_count + 1
            txt.push(str.format("{0}@",level))
        state_dn := txt.size() > 1 ? StateLevel.crossed_multiple : StateLevel.crossed
    else if closeint_floor[1] == closeint_ceil and lastdirection(closeint_ceil) > 0 and
         (close[1] > close) and
         (close < closeint_floor[1] and closeint_floor[1] <= close[1])
        level_crossed_arr.push(closeint_ceil)
        level_crossed_count := level_crossed_count + 1
        txt.push(str.format("{0}v{1}",closeint_ceil,lvl(closeint_ceil)))
        state_dn := StateLevel.crossed
    else if closeint_floor[1] == openint_ceil and lastdirection(closeint_ceil) > 0 and
         (close[1] > open) and
         (open < closeint_floor[1] and closeint_floor[1] <= close[1])
        level_crossed_arr.push(openint_ceil)
        level_crossed_count := level_crossed_count + 1
        txt.push(str.format("{0}*{1}",openint_ceil,lvl(closeint_ceil)))
        state_dn := StateLevel.crossed


    if highint_ceil - math.max(close, open) < roundzone1
        if lastdirection(highint_ceil) < 0
            level_near := highint_ceil
            level_near_count := level_near_count + 1
            txt.push(str.format("under {0}",highint_ceil))
            state_up := StateLevel.near

    if math.min(close, open) - lowint_floor < roundzone1
        if lastdirection(lowint_floor) > 0
            level_near := lowint_floor
            level_near_count := level_near_count + 1
            txt.push(str.format("above {0}",lowint_floor))
            state_dn := StateLevel.near

    if (low < highint_floor and highint_floor <= high) and math.max(close, open) <= highint_floor
        if lastdirection(highint_floor) < 0
            level_touched := highint_floor
            level_touched_count := level_touched_count + 1
            if high > highint_floor
                txt.push(str.format("touched {0}",highint_floor))
                state_up := StateLevel.touched
            else
                txt.push(str.format("hit {0}",highint_floor))
                state_up := StateLevel.reached

    if (low <= lowint_ceil and lowint_ceil < high) and math.min(close, open) >= lowint_ceil
        if lastdirection(lowint_ceil) > 0
            level_touched := lowint_ceil
            level_touched_count := level_touched_count + 1
            if low < lowint_ceil
                txt.push(str.format("touched {0}",lowint_ceil))
                state_dn := StateLevel.touched
            else
                txt.push(str.format("hit {0}",lowint_ceil))
                state_dn := StateLevel.reached


islevelchanged(currvalue,lastvalue) =>
    not na(currvalue) and not na(lastvalue) and currvalue != lastvalue
boostmult(count) =>
    switch
        count >= 256 => 256  // max every 256's bar (~2hour)
        count >= 128 => 128
        count >= 64 => 64
        count >= 32 => 32
        count >= 16 => 16
        count >= 8 => 8
        count >= 4 => 4
        count >= 2 => 2
        => 1
var boostcounter_chooser = 0
boostcounter(int arg=na) =>
    chooser = nz(arg, boostcounter_chooser)
    switch chooser
        0 => level_near_count
        1 => barsanyval
        2 => barsany

level_crossed = level_crossed_arr.size() > 0 ? level_crossed_arr.last() : na

if islevelchanged(level_crossed, last_level_crossed)
    level_crossed_count := 0
    boostcounter_chooser := 0
if islevelchanged(level_touched, last_level_touched)
    level_touched_count := 0
if islevelchanged(level_near, last_level_near)
    level_near_count := 0
if isanyval
    boostcounter_chooser := 1

printlabel(count,dir) =>
    mult = boostmult(count)
    if timestamp("26 Feb 2025 11:30:00 GMT+3") <= time and time <= timestamp("26 Feb 2025 13:45:00 GMT+3")
        log.info("{0} {1} : {2} % {3} = {4}", level_near, last_level_near, count, mult, count % mult)
    if count % mult == 0 
        if dir == "up"
            debugLabelUp(txt.join(","))
        else if dir == "dn"
            debugLabelDn(txt.join(","))

// if isany
switch state_up
    // StateLevel.crossed_multiple => printlabel(level_crossed_count,"up")
    // StateLevel.crossed => printlabel(level_crossed_count,"up")
    // StateLevel.reached =>  debugLabelUp(txt.join(","))
    // StateLevel.touched =>  debugLabelUp(txt.join(","))
    StateLevel.near => printlabel(boostcounter(),"up")
switch state_dn
    // StateLevel.crossed_multiple => printlabel(level_crossed_count,"dn")
    // StateLevel.crossed => printlabel(level_crossed_count,"dn")
    // StateLevel.reached => debugLabelDn(txt.join(","))
    // StateLevel.touched => debugLabelDn(txt.join(","))
    StateLevel.near => printlabel(boostcounter(),"dn")

if not na(level_crossed)
    last_level_crossed := level_crossed
if not na(level_touched)
    last_level_touched := level_touched
if not na(level_near)
    last_level_near := level_near


colorplotvalue = switch
    isvalueP100 => color.new(color.purple, 35)
    isvalueP99 => color.new(color.blue, 35)
    isvcum1m => color.new(color.gray, 50)
    isvcum3m => color.new(color.blue, 50)
    isvcum5m => color.new(color.olive, 50)
    isvcum10m => color.new(color.olive, 75)
    => color.new(color.gray, 75)

bgcolorall = switch
    isvalueP100 => color.new(color.purple, 85)
    isvalueP99 => color.new(color.blue, 85)
    isvcum1m => color.new(color.gray, 85)
    isvcum3m => color.new(color.blue, 90)
    //isvcum5m => color.new(color.olive, 85)
    //isvcum10m => color.new(color.olive, 95)
    => na
bgcolorall_1 = switch
    isvalueP100 => color.new(color.purple, 85)
    isvalueP99 => color.new(color.blue, 85)
    isvcum1m => color.new(color.gray, 85)
    isvcum3m => color.new(color.blue, 90)
    isvcum5m => color.new(color.olive, 85)
    isvcum10m => color.new(color.olive, 95)
    => na

plot(value, color=colorplotvalue, style=plot.style_columns, title="Value")

bgcolor(bgcolorall_1, editable = false, display = dispBg ? display.all : display.none)
bgcolor(bgcolorall, editable = false, display = dispBg ? display.all : display.none, force_overlay = true)



// ALERTS


var level = float(na)
//var 
